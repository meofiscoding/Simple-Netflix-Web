{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nfunction parse(string, encoding, opts) {\n  var _opts$out;\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  // Build the character lookup table:\n  if (!encoding.codes) {\n    encoding.codes = {};\n    for (var i = 0; i < encoding.chars.length; ++i) {\n      encoding.codes[encoding.chars[i]] = i;\n    }\n  } // The string must have a whole number of bytes:\n\n  if (!opts.loose && string.length * encoding.bits & 7) {\n    throw new SyntaxError('Invalid padding');\n  } // Count the padding bytes:\n\n  var end = string.length;\n  while (string[end - 1] === '=') {\n    --end; // If we get a whole number of bytes, there is too much padding:\n\n    if (!opts.loose && !((string.length - end) * encoding.bits & 7)) {\n      throw new SyntaxError('Invalid padding');\n    }\n  } // Allocate the output:\n\n  var out = new ((_opts$out = opts.out) != null ? _opts$out : Uint8Array)(end * encoding.bits / 8 | 0); // Parse the data:\n\n  var bits = 0; // Number of bits currently in the buffer\n\n  var buffer = 0; // Bits waiting to be written out, MSB first\n\n  var written = 0; // Next byte to write\n\n  for (var _i = 0; _i < end; ++_i) {\n    // Read one character from the string:\n    var value = encoding.codes[string[_i]];\n    if (value === undefined) {\n      throw new SyntaxError('Invalid character ' + string[_i]);\n    } // Append the bits to the buffer:\n\n    buffer = buffer << encoding.bits | value;\n    bits += encoding.bits; // Write out some bits if the buffer has a byte's worth:\n\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 0xff & buffer >> bits;\n    }\n  } // Verify that we have received just enough bits:\n\n  if (bits >= encoding.bits || 0xff & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n}\nfunction stringify(data, encoding, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  var _opts = opts,\n    _opts$pad = _opts.pad,\n    pad = _opts$pad === void 0 ? true : _opts$pad;\n  var mask = (1 << encoding.bits) - 1;\n  var out = '';\n  var bits = 0; // Number of bits currently in the buffer\n\n  var buffer = 0; // Bits waiting to be written out, MSB first\n\n  for (var i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = buffer << 8 | 0xff & data[i];\n    bits += 8; // Write out as much as we can:\n\n    while (bits > encoding.bits) {\n      bits -= encoding.bits;\n      out += encoding.chars[mask & buffer >> bits];\n    }\n  } // Partial character:\n\n  if (bits) {\n    out += encoding.chars[mask & buffer << encoding.bits - bits];\n  } // Add padding characters until we hit a byte boundary:\n\n  if (pad) {\n    while (out.length * encoding.bits & 7) {\n      out += '=';\n    }\n  }\n  return out;\n}\n\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nvar base16Encoding = {\n  chars: '0123456789ABCDEF',\n  bits: 4\n};\nvar base32Encoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bits: 5\n};\nvar base32HexEncoding = {\n  chars: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bits: 5\n};\nvar base64Encoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bits: 6\n};\nvar base64UrlEncoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bits: 6\n};\nvar base16 = {\n  parse: function parse$1(string, opts) {\n    return parse(string.toUpperCase(), base16Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base16Encoding, opts);\n  }\n};\nvar base32 = {\n  parse: function parse$1(string, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    return parse(opts.loose ? string.toUpperCase().replace(/0/g, 'O').replace(/1/g, 'L').replace(/8/g, 'B') : string, base32Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base32Encoding, opts);\n  }\n};\nvar base32hex = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base32HexEncoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base32HexEncoding, opts);\n  }\n};\nvar base64 = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base64Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base64Encoding, opts);\n  }\n};\nvar base64url = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base64UrlEncoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base64UrlEncoding, opts);\n  }\n};\nvar codec = {\n  parse: parse,\n  stringify: stringify\n};\nexports.base16 = base16;\nexports.base32 = base32;\nexports.base32hex = base32hex;\nexports.base64 = base64;\nexports.base64url = base64url;\nexports.codec = codec;","map":{"version":3,"names":["Object","defineProperty","exports","value","parse","string","encoding","opts","_opts$out","codes","i","chars","length","loose","bits","SyntaxError","end","out","Uint8Array","buffer","written","_i","undefined","stringify","data","_opts","_opts$pad","pad","mask","base16Encoding","base32Encoding","base32HexEncoding","base64Encoding","base64UrlEncoding","base16","parse$1","toUpperCase","stringify$1","base32","replace","base32hex","base64","base64url","codec"],"sources":["/Users/admin/Downloads/Simple-Netflix-Web/NetlfixClient/node_modules/rfc4648/lib/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nfunction parse(string, encoding, opts) {\n  var _opts$out;\n\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  // Build the character lookup table:\n  if (!encoding.codes) {\n    encoding.codes = {};\n\n    for (var i = 0; i < encoding.chars.length; ++i) {\n      encoding.codes[encoding.chars[i]] = i;\n    }\n  } // The string must have a whole number of bytes:\n\n\n  if (!opts.loose && string.length * encoding.bits & 7) {\n    throw new SyntaxError('Invalid padding');\n  } // Count the padding bytes:\n\n\n  var end = string.length;\n\n  while (string[end - 1] === '=') {\n    --end; // If we get a whole number of bytes, there is too much padding:\n\n    if (!opts.loose && !((string.length - end) * encoding.bits & 7)) {\n      throw new SyntaxError('Invalid padding');\n    }\n  } // Allocate the output:\n\n\n  var out = new ((_opts$out = opts.out) != null ? _opts$out : Uint8Array)(end * encoding.bits / 8 | 0); // Parse the data:\n\n  var bits = 0; // Number of bits currently in the buffer\n\n  var buffer = 0; // Bits waiting to be written out, MSB first\n\n  var written = 0; // Next byte to write\n\n  for (var _i = 0; _i < end; ++_i) {\n    // Read one character from the string:\n    var value = encoding.codes[string[_i]];\n\n    if (value === undefined) {\n      throw new SyntaxError('Invalid character ' + string[_i]);\n    } // Append the bits to the buffer:\n\n\n    buffer = buffer << encoding.bits | value;\n    bits += encoding.bits; // Write out some bits if the buffer has a byte's worth:\n\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 0xff & buffer >> bits;\n    }\n  } // Verify that we have received just enough bits:\n\n\n  if (bits >= encoding.bits || 0xff & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n\n  return out;\n}\nfunction stringify(data, encoding, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  var _opts = opts,\n      _opts$pad = _opts.pad,\n      pad = _opts$pad === void 0 ? true : _opts$pad;\n  var mask = (1 << encoding.bits) - 1;\n  var out = '';\n  var bits = 0; // Number of bits currently in the buffer\n\n  var buffer = 0; // Bits waiting to be written out, MSB first\n\n  for (var i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = buffer << 8 | 0xff & data[i];\n    bits += 8; // Write out as much as we can:\n\n    while (bits > encoding.bits) {\n      bits -= encoding.bits;\n      out += encoding.chars[mask & buffer >> bits];\n    }\n  } // Partial character:\n\n\n  if (bits) {\n    out += encoding.chars[mask & buffer << encoding.bits - bits];\n  } // Add padding characters until we hit a byte boundary:\n\n\n  if (pad) {\n    while (out.length * encoding.bits & 7) {\n      out += '=';\n    }\n  }\n\n  return out;\n}\n\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nvar base16Encoding = {\n  chars: '0123456789ABCDEF',\n  bits: 4\n};\nvar base32Encoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bits: 5\n};\nvar base32HexEncoding = {\n  chars: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bits: 5\n};\nvar base64Encoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bits: 6\n};\nvar base64UrlEncoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bits: 6\n};\nvar base16 = {\n  parse: function parse$1(string, opts) {\n    return parse(string.toUpperCase(), base16Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base16Encoding, opts);\n  }\n};\nvar base32 = {\n  parse: function parse$1(string, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    return parse(opts.loose ? string.toUpperCase().replace(/0/g, 'O').replace(/1/g, 'L').replace(/8/g, 'B') : string, base32Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base32Encoding, opts);\n  }\n};\nvar base32hex = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base32HexEncoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base32HexEncoding, opts);\n  }\n};\nvar base64 = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base64Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base64Encoding, opts);\n  }\n};\nvar base64url = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base64UrlEncoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base64UrlEncoding, opts);\n  }\n};\nvar codec = {\n  parse: parse,\n  stringify: stringify\n};\n\nexports.base16 = base16;\nexports.base32 = base32;\nexports.base32hex = base32hex;\nexports.base64 = base64;\nexports.base64url = base64url;\nexports.codec = codec;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}